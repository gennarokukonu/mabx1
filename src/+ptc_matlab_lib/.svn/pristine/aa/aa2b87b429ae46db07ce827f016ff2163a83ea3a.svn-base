function varargout = uiedit_NumericVariable(varargin)
%uiedit_NumericVariable:
%
%   SYNTAX:
%   uiedit_NumericVariable('NumericVariable', {}, ...
%       'WindowStyle', <'modal'>)
%
%   See also: uiedit_SimulinkParameter, uiedit_SimulinkSignal

import('ptc_matlab_lib.*');

pairs = {'NumericVariable', {}, ...
    'WindowStyle', 'modal', ...
    'UpperLimit', complex(Inf, Inf), ...
    'LowerLimit', complex(-Inf, -Inf), ...
    'AllowNaNs', true, ...
    'AllowImaginary', true, ...
    'AllowResize', true, ...
    'AllowUpperLimitAdjustment', true, ...
    'AllowLowerLimitAdjustment', true, ...
    'VariableName', '', ...
    'VariableUnits', ''};
parseargs(varargin, pairs);

if ~iscell(NumericVariable)
    NumericVariable = {NumericVariable};
end

updatedNumericVariable = cell(size(NumericVariable));
cancelled = false(size(NumericVariable));
for ctr = 1:numel(NumericVariable)
    [updatedNumericVariable{ctr}, cancelled(ctr)] = uiedit_NumericVariable_helper('action', 'init', ...
        'NumericVariable', NumericVariable{ctr}, ...
        'WindowStyle', WindowStyle, ...
        'UpperLimit', UpperLimit, ...
        'LowerLimit', LowerLimit, ...
        'AllowNaNs', AllowNaNs, ...
        'AllowImaginary', AllowImaginary, ...
        'AllowResize', AllowResize, ...
        'AllowUpperLimitAdjustment', AllowUpperLimitAdjustment, ...
        'AllowLowerLimitAdjustment', AllowLowerLimitAdjustment, ...
        'VariableName', VariableName, ...
        'VariableUnits', VariableUnits);
end

varargout{1} = updatedNumericVariable;
varargout{2} = cancelled;

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function varargout = uiedit_NumericVariable_helper(varargin)

import('ptc_matlab_lib.*');

if length(varargin) >= 2 && isscalar(varargin{1}) && ishghandle(varargin{1})
    %This is a GUI Callback
    SRC_HANDLE = varargin{1}; %#ok<NASGU>
    EVENT_DATA = varargin{2}; %#ok<NASGU>
    assert(length(varargin) >= 2);
    varargin = varargin(3:end);
else
    SRC_HANDLE = []; %#ok<NASGU>
    EVENT_DATA = struct([]); %#ok<NASGU>
end

pairs = {'action', ''};
parseargs(varargin, pairs);

persistent DELETE_THESE_HANDLES;
persistent FIGURE_HANDLE;
persistent NUMERIC_VARIABLE;
persistent CANCELLED;
persistent ALLOW_NANS;
persistent ALLOW_IMAGINARY;
persistent ALLOW_RESIZE;
persistent AXES_HANDLE;
persistent VARIABLE_NAME;
persistent VARIABLE_UNITS;

switch action
    %% CASE init
    case 'init'
        pairs = {'NumericVariable', [], ...
            'WindowStyle', 'modal', ...
            'UpperLimit', complex(Inf, Inf), ...
            'LowerLimit', complex(-Inf, -Inf), ...
            'AllowNaNs', true, ...
            'AllowImaginary', true, ...
            'AllowResize', true, ...
            'AllowUpperLimitAdjustment', true, ...
            'AllowLowerLimitAdjustment', true, ...
            'VariableName', '', ...
            'VariableUnits', ''};
        parseargs(varargin, pairs);
        
        if ~isa(NumericVariable, 'ptc_matlab_lib.ndtable')
            if ~ismatrix(NumericVariable)
                waitfor(errordlg('ERROR: Cannot support variables with number of dimensions greater than 2.', 'ERROR', 'modal'));
                theseAxes = arrayfun(@(X) 1:size(NumericVariable, X), 1:ndims(NumericVariable), ...
                    'UniformOutput', false);
                NumericVariable = ndtable('Axes', theseAxes, ...
                    'AxisLabels', repmat({'Index'}, ndims(NumericVariable), 1), ...
                    'AxisUnits', repmat({''}, ndims(NumericVariable), 1), ...
                    'Value', NumericVariable, ...
                    'ValueLabel', VariableName, ...
                    'ValueUnit', VariableUnits, ...
                    'Max', UpperLimit, ...
                    'Min', LowerLimit);
                varargout{1} = NumericVariable;
                varargout{2} = false;
                return;
            end
            
            if isempty(NumericVariable)
                NumericVariable = ndtable('Axes', {}, ...
                    'AxisLabels', {}, ...
                    'AxisUnits', {}, ...
                    'Value', [], ...
                    'ValueLabel', VariableName, ...
                    'ValueUnit', VariableUnits, ...
                    'Max', UpperLimit, ...
                    'Min', LowerLimit);
            elseif isvector(NumericVariable)
                NumericVariable = ndtable('Axes', {1:length(NumericVariable)}, ...
                    'AxisLabels', {'Index'}, ...
                    'AxisUnits', {''}, ...
                    'Value', NumericVariable, ...
                    'ValueLabel', VariableName, ...
                    'ValueUnit', VariableUnits, ...
                    'Max', UpperLimit, ...
                    'Min', LowerLimit);
            else
                NumericVariable = ndtable('Axes', {1:rows(NumericVariable), 1:cols(NumericVariable)}, ...
                    'AxisLabels', {'Row', 'Column'}, ...
                    'AxisUnits', {'', ''}, ...
                    'Value', NumericVariable, ...
                    'ValueLabel', VariableName, ...
                    'ValueUnit', VariableUnits, ...
                    'Max', UpperLimit, ...
                    'Min', LowerLimit);
            end
        end
        
        assert(isa(NumericVariable, 'ptc_matlab_lib.ndtable'));
        
        %If any of the elements of the variable being edited is imaginary
        %or a NaN, we need to allow imaginary numbers and NaNs. Similarly,
        %we may need to override UpperLimit and LowerLimit settings here.
        if ~AllowImaginary
            NumericVariable = NumericVariable.setprop('Value', real(NumericVariable.Value));
        end
        NumericVariable = NumericVariable.setprop('Value', limit('InMatrix', NumericVariable.Value, 'UpperLimit', UpperLimit, 'LowerLimit', LowerLimit));
        
        NUMERIC_VARIABLE = NumericVariable;
        CANCELLED = false;
        ALLOW_NANS = AllowNaNs;
        ALLOW_IMAGINARY = AllowImaginary;
        ALLOW_RESIZE = AllowResize;
        VARIABLE_NAME = VariableName;
        VARIABLE_UNITS = VariableUnits;
        
        pairs = {['fig_' mfilename '_position'],      [0.30893     0.16476     0.59583      0.5981], ...
            'axesValue_position',      [0.648347052947053   0.223301636873902   0.300700099900100   0.480095908251688], ...
            'btnAutosetRowIndices_position',     [0.031968     0.67357    0.016983    0.030255], ...
            'btnAutosetColumnIndices_position',     [0.048951     0.70382    0.016983    0.030255], ...
            'editValueLabel_position',      [0.14885    0.054227     0.14985     0.03509], ...
            'editAxis2Label_position',      [0.14885     0.08932     0.14985     0.03509], ...
            'editAxis1Label_position',      [0.14885     0.12441     0.14985     0.03509], ...
            'textValue_position',     [0.047952    0.052635      0.1009    0.036685], ...
            'popupValueUnit_position',       [0.2987     0.05742      0.2008      0.0319], ...
            'textAxis2_position',     [0.047952    0.087725      0.1009    0.036685], ...
            'popupAxis2Unit_position',       [0.2987     0.09251      0.2008      0.0319], ...
            'textAxis1_position',     [0.047952     0.12441      0.1009    0.036685], ...
            'popupAxis1Unit_position',       [0.2987      0.1276      0.2008      0.0319], ...
            'toggleRealImaginary_position',      [0.95029     0.53321    0.016611    0.029499], ...
            'btnRefreshAxes_position',      [0.95029     0.56116    0.016611    0.029499], ...
            'togglePanMode_position',      [0.95029     0.58911    0.016611    0.029499], ...
            'toggleDataCursorMode_position',      [0.95029     0.61706    0.016611    0.029499], ...
            'toggleRotate3d_position',      [0.95029     0.64501    0.016611    0.029499], ...
            'toggleZoomOut_position',      [0.95029     0.67296    0.016611    0.029499], ...
            'toggleZoomIn_position',      [0.95029     0.70091    0.016611    0.029499], ...
            'btnSetTableData_position',      [0.43057     0.18024     0.16983     0.03509], ...
            'editTableData_position',      [0.32967     0.18024      0.0999     0.03509], ...
            'btnSetSelectedCells_position',      [0.14949     0.18075      0.1696    0.035709], ...
            'editTableCellValue_position',     [0.048957     0.18075    0.099662    0.035709], ...
            'tableValue_position',     [0.048951      0.2233     0.55045      0.4801], ...
            'textNumericVariableEditor_position',     [0.048951     0.91706      0.9001    0.043065], ...
            'editUpperLimit_position',      [0.44955     0.83412      0.0999     0.03509], ...
            'textUpperLimit_position',      [0.34865     0.83412      0.1009    0.036685], ...
            'btnUpdateUpperLimit_position',      [0.55045     0.83252    0.070929     0.03509], ...
            'editLowerLimit_position',      [0.44955     0.79265      0.0999     0.03509], ...
            'textLowerLimit_position',      [0.34865     0.79265      0.1009    0.036685], ...
            'btnUpdateLowerLimit_position',      [0.55045     0.79105    0.070929     0.03509], ...
            'editStepSize_position',      [0.14985     0.75118      0.0999     0.03509], ...
            'textStepSize_position',     [0.048951     0.75118      0.1009    0.036685], ...
            'btnDivide_position',      [0.31056     0.75118    0.020979     0.03509], ...
            'btnMultiply_position',      [0.29058     0.75118    0.020979     0.03509], ...
            'btnSubtract_position',      [0.26973     0.75118    0.020979     0.03509], ...
            'btnAdd_position',      [0.24975     0.75118    0.020979     0.03509], ...
            'editColumns_position',      [0.14985     0.79425      0.0999     0.03509], ...
            'textColumns_position',     [0.048951     0.79265      0.1009    0.036685], ...
            'editRows_position',      [0.14985     0.83572      0.0999     0.03509], ...
            'textRows_position',     [0.048951     0.83572      0.1009    0.036685], ...
            'btnUpdateRowsColumns_position',      [0.25075     0.79777    0.070929    0.071656], ...
            'btnReset_position',      [0.84815    0.059018      0.1009    0.049445], ...
            'btnCancel_position',      [0.74825    0.059018      0.1009    0.049445], ...
            'btnOK_position',      [0.64835    0.059018      0.1009    0.049445]};
        parseargs(pairs);
        
        %If the figure is already open, bring it to the front
        if isfigure(FIGURE_HANDLE)
            figure(FIGURE_HANDLE);
            return;
        end
        
        FIGURE_HANDLE = figure('MenuBar', 'none', ...
            'Name', mfilename, ...
            'Resize', 'off', ...
            'Units', 'normalized', ...
            'WindowStyle', WindowStyle, ...
            'Resize', 'on', ...
            'CreateFcn', {@movegui, 'center'}, ...
            'Position', eval(['fig_' mfilename '_position']), ...
            'DeleteFcn', {str2func(thisfuncname), 'action', 'close'}, ...
            'CloseRequestFcn', {str2func(thisfuncname), 'action', 'btnCancelCallback'});
        DELETE_THESE_HANDLES = FIGURE_HANDLE;
        
        %btnAutosetRowIndices
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnAutosetRowIndices', ...
            'Position', btnAutosetRowIndices_position, ...
            'String', '', ...
            'TooltipString', 'Autoset row indices to (1:rows(cv))', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnAutosetRowIndicesCallback'});
        
        %btnAutosetColumnIndices
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnAutosetColumnIndices', ...
            'Position', btnAutosetColumnIndices_position, ...
            'String', '', ...
            'TooltipString', 'Autoset column indices to (1:cols(cv))', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnAutosetColumnIndicesCallback'});
        
        %btnOK
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnOK', ...
            'Position', btnOK_position, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'OK', ...
            'TooltipString', 'OK', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnOKCallback'});
        
        %btnCancel
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnCancel', ...
            'Position', btnCancel_position, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Cancel', ...
            'TooltipString', 'Cancel', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnCancelCallback'});
        
        %btnReset
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnReset', ...
            'Position', btnReset_position, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Reset', ...
            'TooltipString', 'Reset value', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnResetCallback'});
        
        %btnUpdateRowsColumns
        BooleanStr = {'off', 'on'};
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnUpdateRowsColumns', ...
            'Position', btnUpdateRowsColumns_position, ...
            'FontName', editfont, ...
            'FontSize', 10.0, ...
            'FontWeight', 'bold', ...
            'String', 'UPDATE', ...
            'TooltipString', 'Update rows and columns', ...
            'Enable', BooleanStr{double(AllowResize)+1}, ...
            'Callback', {str2func(thisfuncname), 'action', 'btnUpdateRowsColumnsCallback'});
        
        %textRows
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textRows', ...
            'Position', textRows_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'left', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Rows:', ...
            'TooltipString', 'Rows:');
        
        %editRows
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editRows', ...
            'Position', editRows_position, ...
            'BackgroundColor', 'white', ...
            'HorizontalAlignment', 'center', ...
            'String', num2str(rows(NumericVariable.Value)), ...
            'Enable', BooleanStr{double(AllowResize)+1}, ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editRowsKeyPressFcn'}, ...
            'TooltipString', 'Rows');
        
        %textColumns
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textColumns', ...
            'Position', textColumns_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'left', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Columns:', ...
            'TooltipString', 'Columns:');
        
        %editColumns
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editColumns', ...
            'Position', editColumns_position, ...
            'BackgroundColor', 'white', ...
            'HorizontalAlignment', 'center', ...
            'String', num2str(cols(NumericVariable.Value)), ...
            'Enable', BooleanStr{double(AllowResize)+1}, ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editColumnsKeyPressFcn'}, ...
            'TooltipString', 'Columns');
        
        %btnAdd
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnAdd', ...
            'Position', btnAdd_position, ...
            'FontName', editfont, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', '+', ...
            'TooltipString', 'Add', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnAddCallback'});
        
        %btnSubtract
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnSubtract', ...
            'Position', btnSubtract_position, ...
            'FontName', editfont, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', '-', ...
            'TooltipString', 'Subtract', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnSubtractCallback'});
        
        %btnMultiply
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnMultiply', ...
            'Position', btnMultiply_position, ...
            'FontName', editfont, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', '*', ...
            'TooltipString', 'Multiply', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnMultiplyCallback'});
        
        %btnDivide
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnDivide', ...
            'Position', btnDivide_position, ...
            'FontName', editfont, ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', '/', ...
            'TooltipString', 'Divide', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnDivideCallback'});
        
        %textStepSize
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textStepSize', ...
            'Position', textStepSize_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'left', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Step Size:', ...
            'TooltipString', 'Step Size:');
        
        %editStepSize
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editStepSize', ...
            'Position', editStepSize_position, ...
            'BackgroundColor', 'white', ...
            'HorizontalAlignment', 'center', ...
            'String', '1.0', ...
            'TooltipString', 'Step Size');
        
        %btnUpdateLowerLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnUpdateLowerLimit', ...
            'Position', btnUpdateLowerLimit_position, ...
            'FontName', editfont, ...
            'FontSize', 10.0, ...
            'FontWeight', 'bold', ...
            'String', 'UPDATE', ...
            'TooltipString', 'Update lower limit', ...
            'Enable', BooleanStr{double(AllowLowerLimitAdjustment)+1}, ...
            'Callback', {str2func(thisfuncname), 'action', 'btnUpdateLowerLimitCallback'});
        
        %textLowerLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textLowerLimit', ...
            'Position', textLowerLimit_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'left', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Lower Limit:', ...
            'TooltipString', 'Lower Limit:');
        
        %editLowerLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editLowerLimit', ...
            'Position', editLowerLimit_position, ...
            'BackgroundColor', 'white', ...
            'HorizontalAlignment', 'center', ...
            'String', num2str_custom(LowerLimit, '%1.12g'), ...
            'Enable', BooleanStr{double(AllowLowerLimitAdjustment)+1}, ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editLowerLimitKeyPressFcn'}, ...
            'TooltipString', 'Lower limit');
        
        %btnUpdateUpperLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnUpdateUpperLimit', ...
            'Position', btnUpdateUpperLimit_position, ...
            'FontName', editfont, ...
            'FontSize', 10.0, ...
            'FontWeight', 'bold', ...
            'String', 'UPDATE', ...
            'TooltipString', 'Update upper limit', ...
            'Enable', BooleanStr{double(AllowUpperLimitAdjustment)+1}, ...
            'Callback', {str2func(thisfuncname), 'action', 'btnUpdateUpperLimitCallback'});
        
        %textUpperLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textUpperLimit', ...
            'Position', textUpperLimit_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'left', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Upper Limit:', ...
            'TooltipString', 'Upper Limit:');
        
        %editUpperLimit
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editUpperLimit', ...
            'Position', editUpperLimit_position, ...
            'BackgroundColor', 'white', ...
            'HorizontalAlignment', 'center', ...
            'String', num2str_custom(UpperLimit, '%1.12g'), ...
            'Enable', BooleanStr{double(AllowUpperLimitAdjustment)+1}, ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editUpperLimitKeyPressFcn'}, ...
            'TooltipString', 'Upper limit');
        
        %textNumericVariableEditor
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textNumericVariableEditor', ...
            'Position', textNumericVariableEditor_position, ...
            'BackgroundColor', 'yellow', ...
            'HorizontalAlignment', 'center', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Numeric Variable Editor', ...
            'TooltipString', 'Numeric Variable Editor');
        
        %axesValue
        AXES_HANDLE = axes('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Tag', 'axesValue', ...
            'Position', axesValue_position);
        grid(AXES_HANDLE, 'on');
        
        %tableValue
        tableValue_ContextMenu = uicontextmenu('Parent', FIGURE_HANDLE);
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Delete selected row(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuDeleteSelectedRowsCallback'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Delete selected column(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuDeleteSelectedColumnsCallback'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Insert row before selected cell(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuInsertRowCallback', 'Position', 'before'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Insert column before selected cell(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuInsertColumnCallback', 'Position', 'before'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Insert row after selected cell(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuInsertRowCallback', 'Position', 'after'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Insert column after selected cell(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuInsertColumnCallback', 'Position', 'after'}, ...
            'Enable', BooleanStr{double(AllowResize)+1});
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Edit row indices', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuEditRowIndicesCallback'}, ...
            'Enable', 'on');
        uimenu(tableValue_ContextMenu, ...
            'Label', 'Edit column indices', ...
            'Callback', {str2func(thisfuncname), 'action', 'tableValue_menuEditColumnIndicesCallback'}, ...
            'Enable', 'on');
        
        %Obtain column names and row names
        if isempty(NumericVariable.Value)
            ColumnName = {};
            RowName = {};
        elseif isscalar(NumericVariable.Value)
            ColumnName = {'1'};
            RowName = {'1'};
        elseif iscolumn(NumericVariable.Value)
            ColumnName = {'1'};
            RowName = strtrim(cellstr(num2str(NumericVariable.Axes{1})));
        elseif isrow(NumericVariable.Value)
            ColumnName = strtrim(cellstr(num2str(NumericVariable.Axes{1})));
            RowName = {'1'};
        else
            ColumnName = strtrim(cellstr(num2str(NumericVariable.Axes{2})));
            RowName = strtrim(cellstr(num2str(NumericVariable.Axes{1})));
        end
        h = uitable('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Tag', 'tableValue', ...
            'FontName', editfont, ...
            'Position', tableValue_position, ...
            'ColumnName', ColumnName, ...
            'RowName', RowName, ...
            'Data', NumericVariable.Value, ...
            'UIContextMenu', tableValue_ContextMenu, ...
            'CellSelectionCallback', {str2func(thisfuncname), 'action', 'tableValueCellSelectionCallback'});
        setappdata(h, 'UpperLimit', UpperLimit);
        setappdata(h, 'LowerLimit', LowerLimit);
        if ~isempty(NumericVariable.Value)
            set(h, ...
                'ColumnEditable', false(1, cols(NumericVariable)), ...
                'ColumnFormat', repmat({'numeric'}, 1, cols(NumericVariable)), ...
                'ColumnWidth', repmat({'auto'}, 1, cols(NumericVariable)));
        end
        
        %editTableCellValue
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editTableCellValue', ...
            'Position', editTableCellValue_position, ...
            'String', '', ...
            'TooltipString', 'Value to set the selected cell(s) to', ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editTableCellValueKeyPressFcn'}, ...
            'BackgroundColor', 'white');
        
        %btnSetSelectedCells
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnSetSelectedCells', ...
            'Position', btnSetSelectedCells_position, ...
            'FontName', editfont, ...
            'FontSize', 10.0, ...
            'FontWeight', 'bold', ...
            'String', 'SET SELECTED CELL(S)', ...
            'TooltipString', 'Set selected cell(s)', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnSetSelectedCellsCallback'});
        
        %editTableData
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editTableData', ...
            'Position', editTableData_position, ...
            'String', '', ...
            'TooltipString', 'Value to set the entire table to. (HINT: Use ''cv'' to reference the ''current value'')', ...
            'KeyPressFcn', {str2func(thisfuncname), 'action', 'editTableDataKeyPressFcn'}, ...
            'BackgroundColor', 'white');
        
        %btnSetTableData
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnSetTableData', ...
            'Position', btnSetTableData_position, ...
            'FontName', editfont, ...
            'FontSize', 10.0, ...
            'FontWeight', 'bold', ...
            'String', 'SET TABLE DATA', ...
            'TooltipString', 'Set table data (HINT: Use ''cv'' to reference the ''current value'')', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnSetTableDataCallback'});
        
        %toggleZoomIn
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'toggleZoomIn', ...
            'Position', toggleZoomIn_position, ...
            'String', '', ...
            'TooltipString', 'Zoom in', ...
            'Callback', {str2func(thisfuncname), 'action', 'toggleZoomInCallback'});
        
        %toggleZoomOut
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'toggleZoomOut', ...
            'Position', toggleZoomOut_position, ...
            'String', '', ...
            'TooltipString', 'Zoom out', ...
            'Callback', {str2func(thisfuncname), 'action', 'toggleZoomOutCallback'});
        
        %toggleRotate3d
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'toggleRotate3d', ...
            'Position', toggleRotate3d_position, ...
            'String', '', ...
            'TooltipString', 'Toggle rotate 3D mode', ...
            'Callback', {str2func(thisfuncname), 'action', 'toggleRotate3dCallback'});
        
        %toggleDataCursorMode
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'toggleDataCursorMode', ...
            'Position', toggleDataCursorMode_position, ...
            'String', '', ...
            'TooltipString', 'Toggle data cursor mode', ...
            'Callback', {str2func(thisfuncname), 'action', 'toggleDataCursorModeCallback'});
        
        %togglePanMode
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'togglePanMode', ...
            'Position', togglePanMode_position, ...
            'String', '', ...
            'TooltipString', 'Toggle pan mode', ...
            'Callback', {str2func(thisfuncname), 'action', 'togglePanModeCallback'});
        
        %btnRefreshAxes
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'pushbutton', ...
            'Tag', 'btnRefreshAxes', ...
            'Position', btnRefreshAxes_position, ...
            'String', '', ...
            'TooltipString', 'Refresh axes', ...
            'Callback', {str2func(thisfuncname), 'action', 'btnRefreshAxesCallback'});
        
        %toggleRealImaginary
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'togglebutton', ...
            'Tag', 'toggleRealImaginary', ...
            'Position', toggleRealImaginary_position, ...
            'String', '', ...
            'TooltipString', 'Toggle real/imaginary view', ...
            'Callback', {str2func(thisfuncname), 'action', 'toggleRealImaginaryCallback'});
        
        %textAxis1
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textAxis1', ...
            'Position', textAxis1_position, ...
            'BackgroundColor', 'yellow', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Axis 1:', ...
            'TooltipString', 'Axis 1:', ...
            'HorizontalAlignment', 'left');
        
        %editAxis1Label
        if numel(NUMERIC_VARIABLE.AxisLabels) >= 1
            initLabel = NUMERIC_VARIABLE.AxisLabels{1};
        else
            initLabel = 'Index';
        end
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editAxis1Label', ...
            'Position', editAxis1Label_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', initLabel, ...
            'TooltipString', 'Axis 1 Label', ...
            'Callback', {str2func(thisfuncname), 'action', 'editAxis1LabelCallback'});
        
        %popupAxis1Unit
        h = uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'popup', ...
            'Tag', 'popupAxis1Unit', ...
            'Position', popupAxis1Unit_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', unitslist, ...
            'TooltipString', 'Axis 1 Unit', ...
            'Callback', {str2func(thisfuncname), 'action', 'popupAxis1UnitCallback'});
        if numel(NUMERIC_VARIABLE.AxisLabels) >= 1
            if ~isempty(NUMERIC_VARIABLE.AxisUnits{1})
                setselectedstring(h, NUMERIC_VARIABLE.AxisUnits{1});
            else
                setselectedstring(h, '<empty>');
            end
        end
        
        %textAxis2
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textAxis2', ...
            'Position', textAxis2_position, ...
            'BackgroundColor', 'yellow', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Axis 2:', ...
            'TooltipString', 'Axis 2:', ...
            'HorizontalAlignment', 'left');
        
        %editAxis2Label
        if numel(NUMERIC_VARIABLE.AxisLabels) >= 2
            initLabel = NUMERIC_VARIABLE.AxisLabels{2};
        else
            initLabel = '';
        end
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editAxis2Label', ...
            'Position', editAxis2Label_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', initLabel, ...
            'TooltipString', 'Axis 2 Label', ...
            'Callback', {str2func(thisfuncname), 'action', 'editAxis2LabelCallback'});
        
        %popupAxis2Unit
        h = uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'popup', ...
            'Tag', 'popupAxis2Unit', ...
            'Position', popupAxis2Unit_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', unitslist, ...
            'TooltipString', 'Axis 2 Unit', ...
            'Callback', {str2func(thisfuncname), 'action', 'popupAxis2UnitCallback'});
        if numel(NUMERIC_VARIABLE.AxisLabels) >= 2
            if ~isempty(NUMERIC_VARIABLE.AxisUnits{2})
                setselectedstring(h, NUMERIC_VARIABLE.AxisUnits{2});
            else
                setselectedstring(h, '<empty>');
            end
        end
        
        %textValue
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'text', ...
            'Tag', 'textValue', ...
            'Position', textValue_position, ...
            'BackgroundColor', 'yellow', ...
            'FontSize', 13.0, ...
            'FontWeight', 'bold', ...
            'String', 'Value:', ...
            'TooltipString', 'Value:', ...
            'HorizontalAlignment', 'left');
        
        %editValueLabel
        uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'edit', ...
            'Tag', 'editValueLabel', ...
            'Position', editValueLabel_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', NUMERIC_VARIABLE.ValueLabel, ...
            'TooltipString', 'Value Label', ...
            'Callback', {str2func(thisfuncname), 'action', 'editValueLabelCallback'});
        
        %popupValueUnit
        h = uicontrol('Parent', FIGURE_HANDLE, ...
            'Units', 'normalized', ...
            'Style', 'popup', ...
            'Tag', 'popupValueUnit', ...
            'Position', popupValueUnit_position, ...
            'BackgroundColor', 'white', ...
            'FontName', editfont, ...
            'String', unitslist, ...
            'TooltipString', 'Value Unit', ...
            'Callback', {str2func(thisfuncname), 'action', 'popupValueUnitCallback'});
        if numel(NUMERIC_VARIABLE.ValueLabel) >= 1
            if ~isempty(NUMERIC_VARIABLE.ValueUnit)
                setselectedstring(h, NUMERIC_VARIABLE.ValueUnit);
            else
                setselectedstring(h, '<empty>');
            end
        end
        
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        waitfor(FIGURE_HANDLE);
        varargout{1} = NUMERIC_VARIABLE;
        varargout{2} = CANCELLED;
        clear(mfilename);
        
        %% CASE editAxis1LabelCallback
    case 'editAxis1LabelCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE editAxis2LabelCallback
    case 'editAxis2LabelCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE editValueLabelCallback
    case 'editValueLabelCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE popupAxis1UnitCallback
    case 'popupAxis1UnitCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE popupAxis2UnitCallback
    case 'popupAxis2UnitCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE popupValueUnitCallback
    case 'popupValueUnitCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE toggleZoomInCallback
    case 'toggleZoomInCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        hndlvec = [handles.toggleZoomOut;
            handles.toggleRotate3d;
            handles.toggleDataCursorMode;
            handles.togglePanMode];
        set(hndlvec, 'Value', false);
        
        rotate3d(AXES_HANDLE, 'off');
        datacursormode(FIGURE_HANDLE, 'off');
        set(pan(FIGURE_HANDLE), 'Enable', 'off');
        
        if get(handles.toggleZoomIn, 'Value')
            set(zoom(FIGURE_HANDLE), 'Enable', 'on', 'Direction', 'in');
        else
            set(zoom(FIGURE_HANDLE), 'Enable', 'off');
        end
        
        %% CASE toggleZoomOutCallback
    case 'toggleZoomOutCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        hndlvec = [handles.toggleZoomIn;
            handles.toggleRotate3d;
            handles.toggleDataCursorMode;
            handles.togglePanMode];
        set(hndlvec, 'Value', false);
        
        rotate3d(AXES_HANDLE, 'off');
        datacursormode(FIGURE_HANDLE, 'off');
        set(pan(FIGURE_HANDLE), 'Enable', 'off');
        
        if get(handles.toggleZoomOut, 'Value')
            set(zoom(FIGURE_HANDLE), 'Enable', 'on', 'Direction', 'out');
        else
            set(zoom(FIGURE_HANDLE), 'Enable', 'off');
        end
        
        %% CASE btnRefreshAxesCallback
    case 'btnRefreshAxesCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE toggleRotate3dCallback
    case 'toggleRotate3dCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        hndlvec = [handles.toggleZoomIn;
            handles.toggleZoomOut;
            handles.toggleDataCursorMode;
            handles.togglePanMode];
        set(hndlvec, 'Value', false);
        
        set(zoom(FIGURE_HANDLE), 'Enable', 'off');
        datacursormode(FIGURE_HANDLE, 'off');
        set(pan(FIGURE_HANDLE), 'Enable', 'off');
        
        if get(handles.toggleRotate3d, 'Value')
            rotate3d(AXES_HANDLE, 'on');
        else
            rotate3d(AXES_HANDLE, 'off');
        end
        
        %% CASE toggleDataCursorModeCallback
    case 'toggleDataCursorModeCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        hndlvec = [handles.toggleZoomIn;
            handles.toggleZoomOut;
            handles.toggleRotate3d;
            handles.togglePanMode];
        set(hndlvec, 'Value', false);
        
        set(zoom(FIGURE_HANDLE), 'Enable', 'off');
        rotate3d(AXES_HANDLE, 'off');
        set(pan(FIGURE_HANDLE), 'Enable', 'off');
        
        if get(handles.toggleDataCursorMode, 'Value')
            datacursormode(FIGURE_HANDLE, 'on');
        else
            datacursormode(FIGURE_HANDLE, 'off');
        end
        
        %% CASE togglePanModeCallback
    case 'togglePanModeCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        hndlvec = [handles.toggleZoomIn;
            handles.toggleZoomOut;
            handles.toggleRotate3d;
            handles.toggleDataCursorMode];
        set(hndlvec, 'Value', false);
        
        set(zoom(FIGURE_HANDLE), 'Enable', 'off');
        rotate3d(AXES_HANDLE, 'off');
        datacursormode(FIGURE_HANDLE, 'off');
        
        if get(handles.togglePanMode, 'Value')
            set(pan(FIGURE_HANDLE), 'Enable', 'on');
        else
            set(pan(FIGURE_HANDLE), 'Enable', 'off');
        end
        
        %% CASE toggleRealImaginaryCallback
    case 'toggleRealImaginaryCallback'
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE editRowsKeyPressFcn
    case 'editRowsKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnUpdateRowsColumns);
            feval(thisfuncname, 'action', 'btnUpdateRowsColumnsCallback');
        end
        
        %% CASE editColumnsKeyPressFcn
    case 'editColumnsKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnUpdateColumns);
            feval(thisfuncname, 'action', 'btnUpdateColumnsCallback');
        end
        
        %% CASE editUpperLimitKeyPressFcn
    case 'editUpperLimitKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnUpdateUpperLimit);
            feval(thisfuncname, 'action', 'btnUpdateUpperLimitCallback');
        end
        
        %% CASE editLowerLimitKeyPressFcn
    case 'editLowerLimitKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnUpdateLowerLimit);
            feval(thisfuncname, 'action', 'btnUpdateLowerLimitCallback');
        end
        
        %% CASE tableValue_menuInsertRowCallback
    case 'tableValue_menuInsertRowCallback'
        pairs = {'Position', 'before'};
        parseargs(varargin, pairs);
        
        handles = guihandles(FIGURE_HANDLE);
        selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
        if isempty(selected_subscripts)
            return;
        end
        
        tableValue = get(handles.tableValue, 'Data');
        selected_rows_unique = unique(selected_subscripts(:, 1));
        selected_rows_unique = selected_rows_unique + (0:(length(selected_rows_unique)-1)).';
        selected_columns = repmat(1:cols(tableValue), 1, length(selected_rows_unique));
        selected_rows = num2cell(selected_rows_unique(:));
        selected_rows = cellfun(@(X) repmat(X, ptc_matlab_lib.cols(tableValue), 1), selected_rows, 'UniformOutput', false);
        selected_rows = cell2mat(selected_rows);
        if strcmp(Position, 'after')
            selected_rows = selected_rows + 1;
        end
        indices = sub2ind([rows(tableValue)+length(selected_rows_unique), cols(tableValue)], selected_rows(:), selected_columns(:));
        tableValue = reshape(push(tableValue(:), NaN, indices), rows(tableValue)+length(selected_rows_unique), cols(tableValue));
        
        set(handles.editRows, 'String', num2str(rows(tableValue)));
        newRowName = push(get(handles.tableValue, 'RowName'), ...
            repmat({'NaN'}, 1, numel(unique(selected_rows))), ...
            unique(selected_rows));
        set(handles.tableValue, 'Data', tableValue, 'RowName', newRowName);
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE tableValue_menuInsertColumnCallback
    case 'tableValue_menuInsertColumnCallback'
        pairs = {'Position', 'before'};
        parseargs(varargin, pairs);
        
        handles = guihandles(FIGURE_HANDLE);
        selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
        if isempty(selected_subscripts)
            return;
        end
        
        tableValue = get(handles.tableValue, 'Data');
        selected_columns_unique = unique(selected_subscripts(:, 2));
        selected_columns_unique = selected_columns_unique + (0:(length(selected_columns_unique)-1)).';
        selected_rows = repmat(1:rows(tableValue), 1, length(selected_columns_unique));
        selected_columns = num2cell(selected_columns_unique(:));
        selected_columns = cellfun(@(X) repmat(X, ptc_matlab_lib.rows(tableValue), 1), selected_columns, 'UniformOutput', false);
        selected_columns = cell2mat(selected_columns);
        if strcmp(Position, 'after')
            selected_columns = selected_columns + 1;
        end
        indices = sub2ind([rows(tableValue), cols(tableValue)+length(selected_columns_unique)], selected_rows(:), selected_columns(:));
        tableValue = reshape(push(tableValue(:), NaN, indices), rows(tableValue), cols(tableValue)+length(selected_columns_unique));
        
        set(handles.editRows, 'String', num2str(rows(tableValue)));
        newColumnName = push(get(handles.tableValue, 'ColumnName'), ...
            repmat({'NaN'}, 1, numel(unique(selected_columns))), ...
            unique(selected_columns));
        set(handles.tableValue, 'Data', tableValue, 'ColumnName', newColumnName);
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE tableValue_menuDeleteSelectedRowsCallback
    case 'tableValue_menuDeleteSelectedRowsCallback'
        handles = guihandles(FIGURE_HANDLE);
        selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
        if isempty(selected_subscripts)
            return;
        end
        
        tableValue = get(handles.tableValue, 'Data');
        RowName = get(handles.tableValue, 'RowName');
        selected_rows = unique(selected_subscripts(:, 1));
        tableValue(selected_rows, :) = [];
        RowName(selected_rows) = [];
        
        set(handles.tableValue, 'Data', tableValue, 'RowName', RowName);
        set(handles.editRows, 'String', num2str(rows(tableValue)));
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE tableValue_menuDeleteSelectedColumnsCallback
    case 'tableValue_menuDeleteSelectedColumnsCallback'
        handles = guihandles(FIGURE_HANDLE);
        selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
        if isempty(selected_subscripts)
            return;
        end
        
        tableValue = get(handles.tableValue, 'Data');
        ColumnName = get(handles.tableValue, 'ColumnName');
        selected_columns = unique(selected_subscripts(:, 2));
        tableValue(:, selected_columns) = [];
        ColumnName(selected_columns) = [];
        
        set(handles.tableValue, 'Data', tableValue, 'ColumnName', ColumnName);
        if ~isempty(tableValue)
            set(handles.tableValue, 'ColumnFormat', repmat({'numeric'}, 1, cols(tableValue)), ...
                'ColumnEditable', false(1, cols(tableValue)));
            set(handles.editColumns, 'String', num2str(cols(tableValue)));
        end
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE btnAutosetRowIndicesCallback
    case 'btnAutosetRowIndicesCallback'
        handles = guihandles(FIGURE_HANDLE);
        newRowValues = 1:rows(get(handles.tableValue, 'Data'));
        newRowName = strtrim(cellstr(num2str(newRowValues(:))));
        set(handles.tableValue, 'RowName', newRowName);
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE btnAutosetColumnIndicesCallback
    case 'btnAutosetColumnIndicesCallback'
        handles = guihandles(FIGURE_HANDLE);
        newColumnValues = 1:cols(get(handles.tableValue, 'Data'));
        newColumnName = strtrim(cellstr(num2str(newColumnValues(:))));
        set(handles.tableValue, 'ColumnName', newColumnName);
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE tableValue_menuEditRowIndicesCallback
    case 'tableValue_menuEditRowIndicesCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        handles_to_enable = disable_handles('HandleList', findall(FIGURE_HANDLE));
        
        RowName = get(handles.tableValue, 'RowName');
        RowValues = str2double(RowName);
        RowValues_str = num2str_custom(RowValues);
        cv = get(handles.tableValue, 'Data'); %current value
        
        prompt = 'Enter the row indices:';
        name = '';
        numlines = 1;
        defaultanswer = strtrim(cellstr(RowValues_str));
        options = struct('Resize', 'on', 'WindowStyle', 'modal', 'Interpreter', 'none');
        
        isvalid = false;
        while ~isvalid
            isvalid = true;
            try
                answer = inputdlg(prompt, name, numlines, defaultanswer, options);
                if isempty(answer)
                    %Cancel was pressed
                    enable_handles('HandleList', handles_to_enable);
                    return;
                end
                
                newRowValues = columnvec(evalsafe(answer{1}, {'cv', cv}));
                if any(isnan(newRowValues)) || ...
                        numel(newRowValues) ~= rows(cv) || ...
                        any(diff(newRowValues) <= 0)
                    waitfor(errordlg('ERROR: Invalid row indices.', 'ERROR', 'modal'));
                    isvalid = false;
                else
                    newRowName = strtrim(cellstr(num2str(newRowValues)));
                    set(handles.tableValue, 'RowName', newRowName);
                    feval(thisfuncname, 'action', 'refreshAxesValue');
                end
            catch ME
                waitfor(errordlg({ME.identifier, ME.message}, 'ERROR', 'modal'));
                isvalid = false;
            end
        end
        
        enable_handles('HandleList', handles_to_enable);
        
        %% CASE tableValue_menuEditColumnIndicesCallback
    case 'tableValue_menuEditColumnIndicesCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        handles_to_enable = disable_handles('HandleList', findall(FIGURE_HANDLE));
        
        ColumnName = get(handles.tableValue, 'ColumnName');
        ColumnValues = str2double(ColumnName);
        ColumnValues_str = num2str_custom(ColumnValues);
        cv = get(handles.tableValue, 'Data'); %current value
        
        prompt = 'Enter the column indices:';
        name = '';
        numlines = 1;
        defaultanswer = strtrim(cellstr(ColumnValues_str));
        options = struct('Resize', 'on', 'WindowStyle', 'modal', 'Interpreter', 'none');
        
        isvalid = false;
        while ~isvalid
            isvalid = true;
            try
                answer = inputdlg(prompt, name, numlines, defaultanswer, options);
                if isempty(answer)
                    %Cancel was pressed
                    enable_handles('HandleList', handles_to_enable);
                    return;
                end
                
                newColumnValues = columnvec(evalsafe(answer{1}, {'cv', cv}));
                if any(isnan(newColumnValues)) || ...
                        numel(newColumnValues) ~= cols(cv) || ...
                        any(diff(newColumnValues) <= 0)
                    waitfor(errordlg('ERROR: Invalid column indices.', 'ERROR', 'modal'));
                    isvalid = false;
                else
                    newColumnName = strtrim(cellstr(num2str(newColumnValues)));
                    set(handles.tableValue, 'ColumnName', newColumnName);
                    feval(thisfuncname, 'action', 'refreshAxesValue');
                end
            catch ME
                waitfor(errordlg({ME.identifier, ME.message}, 'ERROR', 'modal'));
                isvalid = false;
            end
        end
        
        enable_handles('HandleList', handles_to_enable);
        
        
        %% CASE editTableCellValueKeyPressFcn
    case 'editTableCellValueKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnSetSelectedCells);
            feval(thisfuncname, 'action', 'btnSetSelectedCellsCallback');
        end
        
        %% CASE btnSetSelectedCellsCallback
    case 'btnSetSelectedCellsCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            
            newValue_str = char(strtrim(get(handles.editTableCellValue, 'String')));
            if isempty(newValue_str)
                return;
            end
            newValue = evalsafe(newValue_str, {'cv', get(handles.tableValue, 'Data')});
            
            selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
            tableValue = get(handles.tableValue, 'Data');
            if isempty(selected_subscripts)
                return;
            end
            selected_indices = unique(sub2ind(size(tableValue), selected_subscripts(:, 1), selected_subscripts(:, 2)));
            
            tableValue(selected_indices) = newValue(:);
            tableValue = limit('InMatrix', tableValue, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            set(handles.tableValue, 'Data', tableValue);
            feval(thisfuncname, 'action', 'refreshAxesValue');
        catch
            waitfor(errordlg('ERROR: Invalid value entered.', 'ERROR', 'modal'));
        end
        
        %% CASE editTableDataKeyPressFcn
    case 'editTableDataKeyPressFcn'
        if (isfield(EVENT_DATA, 'Key') || isprop(EVENT_DATA, 'Key')) && strcmp(EVENT_DATA.Key, 'return')
            handles = guihandles(FIGURE_HANDLE);
            uicontrol(handles.btnSetTableData);
            feval(thisfuncname, 'action', 'btnSetTableDataCallback');
        end
        
        %% CASE btnSetTableDataCallback
    case 'btnSetTableDataCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            
            newValue_str = char(strtrim(get(handles.editTableData, 'String')));
            if isempty(newValue_str)
                return;
            end
            newValue = evalsafe(newValue_str, {'cv', get(handles.tableValue, 'Data')});
            
            newValue = limit('InMatrix', newValue, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            
            if ALLOW_RESIZE
                set(handles.editRows, 'String', rows(newValue));
                set(handles.editColumns, 'String', cols(newValue));
                set(handles.tableValue, 'Data', newValue);
            elseif ~ALLOW_RESIZE && isequal(size(newValue), size(get(handles.tableValue, 'Data')))
                set(handles.tableValue, 'Data', newValue);
            else
                error([mfilename ':' thisfuncname ':InvalidValue']);
            end
            
            %Modify ColumnName and RowName if necessary
            ColumnName = get(handles.tableValue, 'ColumnName');
            RowName = get(handles.tableValue, 'RowName');
            ColumnName = pad_to_length('FinalLength', cols(newValue), ...
                'PadValue', {'NaN'}, ...
                'InputVector', ColumnName, ...
                'PadDirection', 'right');
            RowName = pad_to_length('FinalLength', rows(newValue), ...
                'PadValue', {'NaN'}, ...
                'InputVector', RowName, ...
                'PadDirection', 'right');
            set(handles.tableValue, 'ColumnName', ColumnName, 'RowName', RowName);
            
            feval(thisfuncname, 'action', 'refreshAxesValue');
        catch
            waitfor(errordlg('ERROR: Invalid value entered.', 'ERROR', 'modal'));
        end
        
        %% CASE btnResetCallback
    case 'btnResetCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        set(handles.editRows, 'String', rows(NUMERIC_VARIABLE.Value));
        set(handles.editColumns, 'String', cols(NUMERIC_VARIABLE.Value));
        feval(thisfuncname, 'action', 'btnUpdateRowsColumnsCallback', 'ShouldWarnInformationLoss', false);
        
        if isscalar(NUMERIC_VARIABLE.Value)
            ColumnName = {'1'};
            RowName = {'1'};
        elseif iscolumn(NUMERIC_VARIABLE.Value)
            ColumnName = {'1'};
            RowName = strtrim(cellstr(num2str(NUMERIC_VARIABLE.Axes{1})));
        elseif isrow(NUMERIC_VARIABLE.Value)
            ColumnName = strtrim(cellstr(num2str(NUMERIC_VARIABLE.Axes{1})));
            RowName = {'1'};
        else
            ColumnName = strtrim(cellstr(num2str(NUMERIC_VARIABLE.Axes{2})));
            RowName = strtrim(cellstr(num2str(NUMERIC_VARIABLE.Axes{1})));
        end
        set(handles.tableValue, 'RowName', RowName, 'ColumnName', ColumnName, 'Data', NUMERIC_VARIABLE.Value);
        if ~isempty(NUMERIC_VARIABLE.AxisLabels)
            set(handles.editAxis1Label, 'String', NUMERIC_VARIABLE.AxisLabels{1});
            if isempty(NUMERIC_VARIABLE.AxisUnits{1})
                thisUnit = '<empty>';
            else
                thisUnit = NUMERIC_VARIABLE.AxisUnits{1};
            end
            setselectedstring(handles.popupAxis1Unit, thisUnit);
        end
        if numel(NUMERIC_VARIABLE.AxisLabels) >= 2
            set(handles.editAxis2Label, 'String', NUMERIC_VARIABLE.AxisLabels{2});
            if isempty(NUMERIC_VARIABLE.AxisUnits{2})
                thisUnit = '<empty>';
            else
                thisUnit = NUMERIC_VARIABLE.AxisUnits{2};
            end
            setselectedstring(handles.popupAxis2Unit, thisUnit);
        end
        if ~isempty(NUMERIC_VARIABLE.Value)
            set(handles.editValueLabel, 'String', NUMERIC_VARIABLE.ValueLabel);
            if isempty(NUMERIC_VARIABLE.ValueUnit)
                thisUnit = '<empty>';
            else
                thisUnit = NUMERIC_VARIABLE.ValueUnit;
            end
            setselectedstring(handles.popupValueUnit, thisUnit);
        end
        
        feval(thisfuncname, 'action', 'refreshAxesValue');
        
        %% CASE refreshAxesValue
    case 'refreshAxesValue'
        formatfunc = @(X) ptc_matlab_lib.formatstr(X, 'FormatUnderscores', true, 'FormatBackslashes', true);
        
        handles = guihandles(FIGURE_HANDLE);
        
        tableValue = get(handles.tableValue, 'Data');
        if get(handles.toggleRealImaginary, 'Value')
            %Imaginary
            tableValue = imag(tableValue);
        else
            tableValue = real(tableValue);
        end
        
        ColumnName = get(handles.tableValue, 'ColumnName');
        RowName = get(handles.tableValue, 'RowName');
        ColumnValue = str2double(ColumnName);
        RowValue = str2double(RowName);
        if any(isnan(ColumnValue)) || numel(ColumnValue) ~= cols(tableValue)
            ColumnValue = 1:cols(tableValue);
        end
        if any(isnan(RowValue)) || numel(RowValue) ~= rows(tableValue)
            RowValue = 1:rows(tableValue);
        end
        
        if isempty(tableValue)
            cla(AXES_HANDLE);
            
            XLabel = formatfunc(strtrim(char(get(handles.editAxis1Label, 'String'))));
            XUnit = getselectedstring(handles.popupAxis1Unit);
            idx = strcmp(XUnit{1}{1}, unitslist);
            XUnit = unitslist('Interpreter', 'tex'); XUnit = XUnit{idx};
            XUnit = strexplode(XUnit, ':'); XUnit = strtrim(XUnit{end});
            if ~strcmp(XUnit, '<empty>')
                XLabel = [XLabel ' (' XUnit ')'];
            end
            
            YLabel = formatfunc(strtrim(char(get(handles.editValueLabel, 'String'))));
            YUnit = getselectedstring(handles.popupValueUnit);
            idx = strcmp(YUnit{1}{1}, unitslist);
            YUnit = unitslist('Interpreter', 'tex'); YUnit = YUnit{idx};
            YUnit = strexplode(YUnit, ':'); YUnit = strtrim(YUnit{end});
            if ~strcmp(YUnit, '<empty>')
                YLabel = [YLabel ' (' YUnit ')'];
            end
            
            xlabel(AXES_HANDLE, XLabel);
            ylabel(AXES_HANDLE, YLabel);
            title(AXES_HANDLE, formatfunc(NUMERIC_VARIABLE.ValueLabel));
            grid(AXES_HANDLE, 'on');
            
            set([handles.toggleZoomIn, handles.toggleZoomOut, handles.togglePanMode], 'Enable', 'on');
            set(handles.toggleRotate3d, 'Value', false, 'Enable', 'off');
            rotate3d(AXES_HANDLE, 'off');
        elseif isrow(tableValue)
            if isscalar(tableValue)
                plot(AXES_HANDLE, 1, tableValue, 'o');
            else
                plot(AXES_HANDLE, ColumnValue, tableValue);
            end
            
            XLabel = formatfunc(strtrim(char(get(handles.editAxis1Label, 'String'))));
            XUnit = getselectedstring(handles.popupAxis1Unit);
            idx = strcmp(XUnit{1}{1}, unitslist);
            XUnit = unitslist('Interpreter', 'tex'); XUnit = XUnit{idx};
            XUnit = strexplode(XUnit, ':'); XUnit = strtrim(XUnit{end});
            if ~strcmp(XUnit, '<empty>')
                XLabel = [XLabel ' (' XUnit ')'];
            end
            
            YLabel = formatfunc(strtrim(char(get(handles.editValueLabel, 'String'))));
            YUnit = getselectedstring(handles.popupValueUnit);
            idx = strcmp(YUnit{1}{1}, unitslist);
            YUnit = unitslist('Interpreter', 'tex'); YUnit = YUnit{idx};
            YUnit = strexplode(YUnit, ':'); YUnit = strtrim(YUnit{end});
            if ~strcmp(YUnit, '<empty>')
                YLabel = [YLabel ' (' YUnit ')'];
            end
            
            xlabel(AXES_HANDLE, XLabel);
            ylabel(AXES_HANDLE, YLabel);
            title(AXES_HANDLE, formatfunc(NUMERIC_VARIABLE.ValueLabel));
            grid(AXES_HANDLE, 'on');
            
            set([handles.toggleZoomIn, handles.toggleZoomOut, handles.togglePanMode], 'Enable', 'on');
            set(handles.toggleRotate3d, 'Value', false, 'Enable', 'off');
            rotate3d(AXES_HANDLE, 'off');
        elseif iscolumn(tableValue)
            if isscalar(tableValue)
                plot(AXES_HANDLE, 1, tableValue, 'o');
            else
                plot(AXES_HANDLE, RowValue, tableValue);
            end
            
            XLabel = formatfunc(strtrim(char(get(handles.editAxis1Label, 'String'))));
            XUnit = getselectedstring(handles.popupAxis1Unit);
            idx = strcmp(XUnit{1}{1}, unitslist);
            XUnit = unitslist('Interpreter', 'tex'); XUnit = XUnit{idx};
            XUnit = strexplode(XUnit, ':'); XUnit = strtrim(XUnit{end});
            if ~strcmp(XUnit, '<empty>')
                XLabel = [XLabel ' (' XUnit ')'];
            end
            
            YLabel = formatfunc(strtrim(char(get(handles.editValueLabel, 'String'))));
            YUnit = getselectedstring(handles.popupValueUnit);
            idx = strcmp(YUnit{1}{1}, unitslist);
            YUnit = unitslist('Interpreter', 'tex'); YUnit = YUnit{idx};
            YUnit = strexplode(YUnit, ':'); YUnit = strtrim(YUnit{end});
            if ~strcmp(YUnit, '<empty>')
                YLabel = [YLabel ' (' YUnit ')'];
            end
            
            xlabel(AXES_HANDLE, XLabel);
            ylabel(AXES_HANDLE, YLabel);
            title(AXES_HANDLE, formatfunc(NUMERIC_VARIABLE.ValueLabel));
            grid(AXES_HANDLE, 'on');
            
            set([handles.toggleZoomIn, handles.toggleZoomOut, handles.togglePanMode], 'Enable', 'on');
            set(handles.toggleRotate3d, 'Value', false, 'Enable', 'off');
            rotate3d(AXES_HANDLE, 'off');
        else
            [X, Y] = ndgrid(RowValue, ColumnValue);
            surf(AXES_HANDLE, X, Y, tableValue);
            
            XLabel = formatfunc(strtrim(char(get(handles.editAxis1Label, 'String'))));
            XUnit = getselectedstring(handles.popupAxis1Unit);
            idx = strcmp(XUnit{1}{1}, unitslist);
            XUnit = unitslist('Interpreter', 'tex'); XUnit = XUnit{idx};
            XUnit = strexplode(XUnit, ':'); XUnit = strtrim(XUnit{end});
            if ~strcmp(XUnit, '<empty>')
                XLabel = [XLabel ' (' XUnit ')'];
            end
            
            YLabel = formatfunc(strtrim(char(get(handles.editAxis2Label, 'String'))));
            YUnit = getselectedstring(handles.popupAxis2Unit);
            idx = strcmp(YUnit{1}{1}, unitslist);
            YUnit = unitslist('Interpreter', 'tex'); YUnit = YUnit{idx};
            YUnit = strexplode(YUnit, ':'); YUnit = strtrim(YUnit{end});
            if ~strcmp(YUnit, '<empty>')
                YLabel = [YLabel ' (' YUnit ')'];
            end
            
            ZLabel = formatfunc(strtrim(char(get(handles.editValueLabel, 'String'))));
            ZUnit = getselectedstring(handles.popupValueUnit);
            idx = strcmp(ZUnit{1}{1}, unitslist);
            ZUnit = unitslist('Interpreter', 'tex');
            ZUnit = strexplode(ZUnit{idx}, ':'); ZUnit = strtrim(ZUnit{end});
            if ~strcmp(ZUnit, '<empty>')
                ZLabel = [ZLabel ' (' ZUnit ')'];
            end
            
            xlabel(AXES_HANDLE, XLabel);
            ylabel(AXES_HANDLE, YLabel);
            zlabel(AXES_HANDLE, ZLabel);
            title(AXES_HANDLE, formatfunc(NUMERIC_VARIABLE.ValueLabel));
            grid(AXES_HANDLE, 'on');
            
            set([handles.toggleZoomIn, handles.toggleZoomOut, handles.togglePanMode], 'Value', false, 'Enable', 'off');
            set(zoom(FIGURE_HANDLE), 'Enable', 'off');
            set(pan(FIGURE_HANDLE), 'Enable', 'off');
            set(handles.toggleRotate3d, 'Enable', 'on');
            if get(handles.toggleRotate3d, 'Value')
                rotate3d(AXES_HANDLE, 'on');
            else
                rotate3d(AXES_HANDLE, 'off');
            end
        end
        
        %% CASE tableValueCellSelectionCallback
    case 'tableValueCellSelectionCallback'
        setappdata(SRC_HANDLE, 'SelectedSubscripts', EVENT_DATA.Indices);
        
        %% CASE btnOKCallback
    case 'btnOKCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        Value = get(handles.tableValue, 'Data');
        UpperLimit = getappdata(handles.tableValue, 'UpperLimit');
        LowerLimit = getappdata(handles.tableValue, 'LowerLimit');
        ValueLabel = char(strtrim(get(handles.editValueLabel, 'String')));
        ValueUnit = getselectedstring(handles.popupValueUnit); ValueUnit = ValueUnit{1}{1};
        
        if ~isempty(Value)
            if isrow(Value)
                Axis1 = str2double(columnvec(get(handles.tableValue, 'ColumnName')));
            else
                Axis1 = str2double(columnvec(get(handles.tableValue, 'RowName')));
            end
            if any(isnan(Axis1))
                waitfor(errordlg('ERROR: Axis cannot contain NaNs', 'ERROR', 'modal'));
                return;
            end
            Axis1Label = char(strtrim(get(handles.editAxis1Label, 'String')));
            Axis1Unit = getselectedstring(handles.popupAxis1Unit); Axis1Unit = Axis1Unit{1}{1};
            
            if ~isvector(Value)
                Axis2 = str2double(columnvec(get(handles.tableValue, 'ColumnName')));
                if any(isnan(Axis2))
                    waitfor(errordlg('Error: Axis cannot contain NaNs', 'ERROR', 'modal'));
                    return;
                end
                Axis2Label = char(strtrim(get(handles.editAxis2Label, 'String')));
                Axis2Unit = getselectedstring(handles.popupAxis2Unit); Axis2Unit = Axis2Unit{1}{1};
                
                Axes = {Axis1(:); Axis2(:)};
                AxisLabels = {Axis1Label; Axis2Label};
                AxisUnits = {Axis1Unit; Axis2Unit};
            else
                Axes = {Axis1(:)};
                AxisLabels = {Axis1Label};
                AxisUnits = {Axis1Unit};
            end
        else
            Axes = cell(0, 1);
            AxisLabels = cell(0, 1);
            AxisUnits = cell(0, 1);
        end
        
        NumericVariable = ndtable('Axes', Axes, ...
            'AxisLabels', AxisLabels, ...
            'AxisUnits', AxisUnits, ...
            'Value', Value, ...
            'ValueLabel', ValueLabel, ...
            'ValueUnit', ValueUnit, ...
            'Max', UpperLimit, ...
            'Min', LowerLimit);
        
        if any(isnan(NumericVariable.Value(:))) && ~ALLOW_NANS
            waitfor(errordlg('ERROR: NaNs are not permitted.', 'ERROR', 'modal'));
            return;
        end
        
        NUMERIC_VARIABLE = NumericVariable;
        CANCELLED = false;
        feval(thisfuncname, 'action', 'close');
        
        %% CASE btnCancelCallback
    case 'btnCancelCallback'
        NUMERIC_VARIABLE = [];
        CANCELLED = true;
        feval(thisfuncname, 'action', 'close');
        
        %% CASE btnUpdateUpperLimitCallback
    case 'btnUpdateUpperLimitCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        try
            tableValue = get(handles.tableValue, 'Data');
            newUpperLimit = evalsafe(char(strtrim(get(handles.editUpperLimit, 'String'))), {'cv', tableValue});
            tableValue = limit('InMatrix', tableValue, 'UpperLimit', newUpperLimit);
            set(handles.tableValue, 'Data', tableValue);
            setappdata(handles.tableValue, 'UpperLimit', newUpperLimit);
            feval(thisfuncname, 'action', 'refreshAxesValue');
        catch
            waitfor(errordlg('ERROR: Invalid upper limit specified', 'ERROR', 'modal'));
        end
        
        %% CASE btnUpdateLowerLimitCallback
    case 'btnUpdateLowerLimitCallback'
        handles = guihandles(FIGURE_HANDLE);
        
        try
            tableValue = get(handles.tableValue, 'Data');
            newLowerLimit = evalsafe(char(strtrim(get(handles.editLowerLimit, 'String'))), {'cv', tableValue});
            tableValue = limit('InMatrix', tableValue, 'LowerLimit', newLowerLimit);
            set(handles.tableValue, 'Data', tableValue);
            setappdata(handles.tableValue, 'LowerLimit', newLowerLimit);
            feval(thisfuncname, 'action', 'refreshAxesValue');
        catch
            waitfor(errordlg('ERROR: Invalid lower limit specified', 'ERROR', 'modal'));
        end
        
        %% CASE btnUpdateRowsColumnsCallback
    case 'btnUpdateRowsColumnsCallback'
        pairs = {'ShouldWarnInformationLoss', true};
        parseargs(varargin, pairs);
        handles = guihandles(FIGURE_HANDLE);
        
        try
            currTableData = get(handles.tableValue, 'Data');
            newRows = evalsafe(get(handles.editRows, 'String'), {'cv', currTableData});
            newColumns = evalsafe(get(handles.editColumns, 'String'), {'cv', currTableData});
            currRows = rows(currTableData);
            currColumns = cols(currTableData);
            newTableData = NaN(newRows, newColumns);
            newTableData(1:min(newRows, currRows), 1:min(newColumns, currColumns)) = currTableData(1:min(newRows, currRows), 1:min(newColumns, currColumns));
            
            if ShouldWarnInformationLoss && (rows(newTableData) < rows(currTableData) || cols(newTableData) < cols(currTableData))
                answer = questdlg('WARNING: About to lose information. Are you sure?', 'Are you sure?', 'YES', 'NO', 'NO');
            else
                answer = 'YES';
            end
            if strcmp(answer, 'YES')
                if ~isempty(newTableData)
                    set(handles.tableValue, 'ColumnFormat', repmat({'numeric'}, 1, cols(newTableData)));
                    set(handles.tableValue, 'ColumnEditable', false(1, cols(newTableData)));
                end
                %Modify ColumnName and RowName if necessary
                ColumnName = get(handles.tableValue, 'ColumnName');
                RowName = get(handles.tableValue, 'RowName');
                ColumnName = pad_to_length('FinalLength', cols(newTableData), ...
                    'PadValue', {'NaN'}, ...
                    'InputVector', ColumnName, ...
                    'PadDirection', 'right');
                RowName = pad_to_length('FinalLength', rows(newTableData), ...
                    'PadValue', {'NaN'}, ...
                    'InputVector', RowName, ...
                    'PadDirection', 'right');
                set(handles.tableValue, 'ColumnName', ColumnName, 'RowName', RowName, 'Data', newTableData);
                
                feval(thisfuncname, 'action', 'refreshAxesValue');
            end
        catch ME
            waitfor(errordlg(ME.message, 'ERROR', 'modal'));
        end
        
        %% CASE btnAddCallback
    case 'btnAddCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
            if isempty(selected_subscripts)
                return;
            end
            tableData = get(handles.tableValue, 'Data');
            selected_indices = sub2ind(size(tableData), selected_subscripts(:, 1), selected_subscripts(:, 2));
            StepSize = evalsafe(char(strtrim(get(handles.editStepSize, 'String'))), {'cv', tableData});
            
            if ~isequal(imag(StepSize), 0.0) && ~ALLOW_IMAGINARY || ~isequal(size(StepSize), [1 1])
                waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
                return;
            end
            
            tableData(selected_indices) = tableData(selected_indices) + StepSize;
            tableData = limit('InMatrix', tableData, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            set(handles.tableValue, 'Data', tableData);
            feval(thisfuncname, 'action', 'refreshAxesValue');
            
            %TODO: FIND A WAY TO PRESERVE CELL SELECTION
        catch
            waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
        end
        
        %% CASE btnSubtractCallback
    case 'btnSubtractCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
            if isempty(selected_subscripts)
                return;
            end
            tableData = get(handles.tableValue, 'Data');
            selected_indices = sub2ind(size(tableData), selected_subscripts(:, 1), selected_subscripts(:, 2));
            StepSize = evalsafe(char(strtrim(get(handles.editStepSize, 'String'))), {'cv', tableData});
            
            if ~isequal(imag(StepSize), 0.0) && ~ALLOW_IMAGINARY || ~isequal(size(StepSize), [1 1])
                waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
                return;
            end
            
            tableData(selected_indices) = tableData(selected_indices) - StepSize;
            tableData = limit('InMatrix', tableData, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            set(handles.tableValue, 'Data', tableData);
            feval(thisfuncname, 'action', 'refreshAxesValue');
            
            %TODO: FIND A WAY TO PRESERVE CELL SELECTION
        catch
            waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
        end
        
        %% CASE btnMultiplyCallback
    case 'btnMultiplyCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
            if isempty(selected_subscripts)
                return;
            end
            tableData = get(handles.tableValue, 'Data');
            selected_indices = sub2ind(size(tableData), selected_subscripts(:, 1), selected_subscripts(:, 2));
            StepSize = evalsafe(char(strtrim(get(handles.editStepSize, 'String'))), {'cv', tableData});
            
            if ~isequal(imag(StepSize), 0.0) && ~ALLOW_IMAGINARY || ~isequal(size(StepSize), [1 1])
                waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
                return;
            end
            
            tableData(selected_indices) = tableData(selected_indices) .* StepSize;
            tableData = limit('InMatrix', tableData, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            set(handles.tableValue, 'Data', tableData);
            feval(thisfuncname, 'action', 'refreshAxesValue');
            
            %TODO: FIND A WAY TO PRESERVE CELL SELECTION
        catch
            waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
        end
        
        %% CASE btnDivideCallback
    case 'btnDivideCallback'
        try
            handles = guihandles(FIGURE_HANDLE);
            selected_subscripts = getappdata(handles.tableValue, 'SelectedSubscripts');
            if isempty(selected_subscripts)
                return;
            end
            tableData = get(handles.tableValue, 'Data');
            selected_indices = sub2ind(size(tableData), selected_subscripts(:, 1), selected_subscripts(:, 2));
            StepSize = evalsafe(char(strtrim(get(handles.editStepSize, 'String'))), {'cv', tableData});
            
            if ~isequal(imag(StepSize), 0.0) && ~ALLOW_IMAGINARY || ~isequal(size(StepSize), [1 1])
                waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
                return;
            end
            
            tableData(selected_indices) = tableData(selected_indices) ./ StepSize;
            tableData = limit('InMatrix', tableData, 'UpperLimit', getappdata(handles.tableValue, 'UpperLimit'), 'LowerLimit', getappdata(handles.tableValue, 'LowerLimit'));
            set(handles.tableValue, 'Data', tableData);
            feval(thisfuncname, 'action', 'refreshAxesValue');
            
            %TODO: FIND A WAY TO PRESERVE CELL SELECTION
        catch
            waitfor(errordlg('ERROR: Invalid stepsize specified.', 'ERROR', 'modal'));
        end
        
        %% CASE close
    case 'close'
        for ctr = 1:numel(DELETE_THESE_HANDLES)
            try
                delete(DELETE_THESE_HANDLES(ctr));
            end
        end
end

end